server:
  http_listen_port: 9080
  grpc_listen_port: 0
  log_level: error  # 保留调试日志，方便排查问题

positions:
  filename: /tmp/positions.yaml  # 记录日志读取位置，避免重复发送

clients:
  - url: http://loki:3100/loki/api/v1/push  # 指向 Loki 服务的地址

scrape_configs:
  - job_name: go-app-logs  # 明确 job 名称，作为保底标签之一
    docker_sd_configs:
      - host: unix:///var/run/docker.sock  # 通过 Docker 套接字发现容器
        refresh_interval: 5s  # 刷新容器列表的间隔

    relabel_configs:
      # 提取 Docker Compose 服务名作为 service 标签（必选标签）
      - source_labels: [ __meta_docker_container_label_com_docker_compose_service ]
        target_label: service
        action: replace  # 确保即使标签值为空也会执行（实际已通过 keep 过滤，这里必然有值）

      # 提取容器名作为 container 标签（去掉开头的斜杠）
      - source_labels: [ __meta_docker_container_name ]
        regex: ^/(.*)$
        target_label: container
        replacement: $1  # 例如将 "/go-app-1" 转换为 "go-app-1"

      # 强制添加 job 标签作为保底（确保至少有一个标签）
      - target_label: job
        replacement: go-app-logs  # 固定值，与 job_name 保持一致

    # 解析 JSON 格式的日志（你的应用配置了 LOG_FORMAT=json）
    pipeline_stages:
#      - logfmt: # 替换 json 为 logfmt
#          mapping:
      - json:
          expressions:
            level: level       # 提取 level=debug 中的 level
            ts: ts             # 提取 ts=2025-12-01T... 中的 ts
            caller: caller     # 提取 caller=xxx 中的 caller
            msg: msg           # 提取 msg=xxx 中的 msg
            method: method     # 若日志有 method=xxx 则提取
            path: path         # 若日志有 path=xxx 则提取
            status: status     # 若日志有 status=xxx 则提取
            user_agent: user_agent  # 若日志有 user_agent=xxx 则提取
            component: component
            type: type
            tsNs: tsNs
            time: time
            traceID: traceID


      # 可选：将解析出的 level 字段映射为 Loki 的日志级别标签（方便查询）
      - labels:
          level:
          status: